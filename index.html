<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Compartilhamento de Tela - WebRTC</title>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth.js"></script>
</head>
<body>
  <h1>Compartilhamento de Tela</h1>
  <button id="shareScreen">Compartilhar Tela</button>
  <video id="localVideo" autoplay muted></video>
  <video id="remoteVideo" autoplay></video>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyAWhfaY2Adp4YJGwvITWTGHP-7zOLNfiGI",
      authDomain: "sandalias-retro-9f0c6.firebaseapp.com",
      databaseURL: "https://sandalias-retro-9f0c6-default-rtdb.firebaseio.com",
      projectId: "sandalias-retro-9f0c6",
      storageBucket: "sandalias-retro-9f0c6.appspot.com",
      messagingSenderId: "786208752798",
      appId: "1:786208752798:web:193f76bbbf5ac4ef27678f",
      measurementId: "G-XGVHLX01EB"
    };

    // Inicialize o Firebase
    const app = firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

    let localStream = null;
    let peerConnection = null;
    const iceServers = [{ urls: 'stun:stun.l.google.com:19302' }];
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');

    // Função para capturar a tela
    async function captureScreen() {
      try {
        localStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
        localVideo.srcObject = localStream;

        if (!peerConnection) {
          createPeerConnection();
        }

        // Adiciona os tracks da tela ao peerConnection
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });

        // Cria a oferta (SDP) e envia para o Firebase
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        const offerData = {
          sdp: offer.sdp,
          type: offer.type
        };

        // Envia a oferta para o Firebase
        firebase.database().ref('offer').set(offerData);

      } catch (error) {
        console.error("Erro ao capturar a tela: ", error);
      }
    }

    // Função para criar a peer connection
    function createPeerConnection() {
      if (peerConnection) {
        console.log("peerConnection já foi criada.");
        return;
      }

      peerConnection = new RTCPeerConnection({ iceServers });

      // Lidar com os candidatos ICE
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          sendIceCandidate(event.candidate);
        }
      };

      // Lidar com o stream remoto
      peerConnection.ontrack = (event) => {
        remoteVideo.srcObject = event.streams[0];
      };

      console.log("peerConnection criada com sucesso.");
    }

    // Função para enviar o candidato ICE para o Firebase
    function sendIceCandidate(candidate) {
      firebase.database().ref('iceCandidates').push(candidate);
    }

    // Função para tratar a resposta (answer) recebida
    function handleAnswer(data) {
      if (!peerConnection) {
        console.error("peerConnection não foi inicializada corretamente.");
        return;
      }

      console.log("Recebendo resposta: ", data);

      const answer = new RTCSessionDescription({
        type: 'answer',
        sdp: data.sdp
      });

      console.log("Configurando a descrição remota com o SDP:", answer.sdp);

      peerConnection.setRemoteDescription(answer)
        .then(() => {
          console.log("Resposta configurada com sucesso.");
        })
        .catch(err => {
          console.error("Erro ao configurar a resposta:", err);
        });
    }

    // Função para lidar com os candidatos ICE
    function handleIceCandidate(candidate) {
      if (!peerConnection) {
        console.error("peerConnection não foi inicializada.");
        return;
      }

      const iceCandidate = new RTCIceCandidate(candidate);

      peerConnection.addIceCandidate(iceCandidate)
        .then(() => {
          console.log("Candidato ICE adicionado com sucesso.");
        })
        .catch(err => {
          console.error("Erro ao adicionar candidato ICE:", err);
        });
    }

    // Função para lidar com a oferta recebida do Firebase
    function handleOffer(data) {
      if (!peerConnection) {
        createPeerConnection();
      }

      const offer = new RTCSessionDescription({
        type: 'offer',
        sdp: data.sdp
      });

      peerConnection.setRemoteDescription(offer)
        .then(() => {
          return peerConnection.createAnswer();
        })
        .then(answer => {
          return peerConnection.setLocalDescription(answer);
        })
        .then(() => {
          const answerData = {
            sdp: peerConnection.localDescription.sdp,
            type: peerConnection.localDescription.type
          };

          // Envia a resposta (answer) de volta para o Firebase
          firebase.database().ref('answer').set(answerData);
        })
        .catch(err => {
          console.error("Erro ao lidar com a oferta:", err);
        });
    }

    // Lidar com dados do Firebase (oferta, resposta e candidatos ICE)
    firebase.database().ref('offer').on('value', (snapshot) => {
      const offerData = snapshot.val();
      if (offerData) {
        handleOffer(offerData);
      }
    });

    firebase.database().ref('answer').on('value', (snapshot) => {
      const answerData = snapshot.val();
      if (answerData) {
        handleAnswer(answerData);
      }
    });

    firebase.database().ref('iceCandidates').on('child_added', (snapshot) => {
      const candidateData = snapshot.val();
      if (candidateData) {
        handleIceCandidate(candidateData);
      }
    });

    // Iniciar o compartilhamento de tela
    document.getElementById('shareScreen').addEventListener('click', captureScreen);

  </script>
</body>
</html>
